### MVC

M 表示 Model 也就是数据模型；V 表示 View 也就是界面视图；C 表示 Controller 也就是控制器，用来协调用户操作、Model、和 View。但是 **MVC 只是给出了这样一个大致的指导原则，并没有具体指明 MVC 各个部分应该承担具体什么职责，相互之间应该如何交互**。这些很大程度上都是由开发工具或者开发框架定义的，如果工具或者框架没有定义，那么就完全靠开发人员自由发挥了。

#### 客户端MVC

控制器负责对模型中的数据进行更新，而视图向模型中请求数据；当有用户的行为触发操作时，会有控制器更新模型，并通知视图进行更新，在这时视图向模型请求新的数据。所以在客户端中，一般Controller的工作量非常大（响应用户事件，更新视图，同步模型，管理视图和模型，代理应用生命周期以及页面生命周期）。执行流程大致为：V->C->M->C->V，可以看出Controller是沟通View和Model的桥梁，并且项目大部分的业务逻辑位于Controller层，而不是在Model层，Model层只起到了数据定义的作用（因此，客户端代码优化的重要方向就是把部分业务逻辑迁移到Model层）。

#### 服务端MVC

View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，**控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。**所以在服务端中，一般Model的工作量非常大（维护着数据，同时封装业务逻辑）。执行流程大致为：C->M->V，控制器的代码量非常少，接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。

### 三层架构

服务端MVC架构会有以下问题：

- 前后端分离，大多数场景下已不再需要服务端渲染`View`；
- `Model`层级的代码既维护着数据，也封装着业务逻辑，随着业务逻辑变得越来越复杂，这一层功能逻辑会变得越来越臃肿不易维护；
- 对于团队管理来讲，`Controller`和`Model`的职责边界比较模糊，很难保证参差不齐的团队成员能够清晰地认识到`Controller`层并不应当封装业务逻辑。对于开发人员写好代码的要求会比较高。

针对以上三个问题，推荐使用三层架构的模式。传统的三层架构设计分为以下三个部分：

- **UI（表示层）**：`User Interface`位于三层构架的最上层，与用户直接接触，主要是`B/S`中的 `WEB`页面，也可以是`API`接口。表示层的主要功能是实现系统数据的传入与输出。换句话说，表示层就是实现用户界面/`API`接口功能，将用户的需求传达和反馈，调用BLL完成业务逻辑，保证用户体验。
- **BLL（业务逻辑层）**：`Business Logic Layer`的功能是对具体问题进行逻辑判断与执行操作，接收到表现层`UI`的用户指令后，会连接数据访问层`DAL`，业务逻辑层在三层构架中位于表示层与数据层中间位置，同时也是表示层与数据层的桥梁，实现三层之间的数据连接和指令传达，可以对接收数据进行逻辑处理，实现数据的增删改查等功能，并将处理结果反馈到表示层`UI`中，实现软件功能。
- **DAL（数据访问层）**：`Data Access Layer`是数据库的主要操控系统，实现数据的增删改查等操作，并将操作结果反馈到业务逻辑层`BLL`。在实际运行的过程中，数据访问层没有逻辑判断能力，为了实现代码编写的严谨性，提高代码阅读程度，一般软件开发人员会在该层中实现通用数据能力，进行封装（例如通过`ORM`组件）来保证数据访问层`DAL`数据处理功能。 

但是在实际开发三种，一般会增加**Model层（模型定义层）**，它不属于三层中的任何一层，但是却尤其重要。模型定义也常用`Entity`实体对象来表示，主要用于数据库表的映射对象，在信息系统软件实际开发的过程中，要建立对象实例，将关系数据库表采用对象实体化的方式表现出来，辅助软件开发中对各个系统功能的控制与操作执行。建立实体类库，进而实现各个结构层的参数传输，提高代码的阅读性。从本质上看，实体类库主要服务于表示层、业务逻辑层以及数据访问层，在三层之间进行数据参数传输，强化数据表示的简约性。需要注意区分的是，这里的`Model`和`MVC`设计模式中的`Model`虽然都是一个名字但是差别巨大，职责完全不同。

在三层架构设计中，`UI`表示层即相当于`MVC`的`View`和`Controller`层，原本在`MVC`中这两层的逻辑应当是比较"轻量"的，因此被合并为一层进行统一管理也可以理解。比较重要的一点是，原本`MVC`中的`Model`被拆分为了`BLL`和`DAL`，即将业务逻辑与数据访问进行分离，将原本臃肿的`Model`进行了进一步的解耦，有利于项目的更好维护。

#### 贫血模型

三层架构中，每层都有对应的数据模型：

- Vo对应UI
- Bo对应BLL
- Model/Entity对应DAL

Vo，Bo，Model/Entity只包含数据，不包含任何的业务逻辑。只包含数据，不包含业务逻辑的类，就叫作贫血模型。贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。

#### 充血模型

数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。在基于贫血模型的传统开发模式中，Service/BLL 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的开发模式中，Service/BL 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的开发模式，轻 Service 重Domain。

#### 如何选择

现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式。出现这种情况的原因主要有以下几点：

- 系统业务比较简单，简单到就是基于SQL 的 CRUD 操作，贫血模型就足以应付这种简单业务的开发工作；除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。
- 充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。
- 思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。

不夸张地讲，我们平时的开发，大部分都是 SQL 驱动的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。

如果我们在项目中，应用基于充血模型的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。**领域模型相当于可复用的业务中间层**。新功能需求的开发，都基于之前定义好的这些领域模型来完成。

基于充血模型的开发模式跟基于贫血模型的传统开发模式相比，UI 层和DAL层的代码基本上相同。这是因为，UI 层和DAL层生命周期有限，UI 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，UI 层和DAL 层继续沿用贫血模型的设计思路是没有问题的。

> DAL与Domian都是Service的底层。DAL复杂数据的存储，Domian负责业务逻辑，Service将两者融合。

任何时候都更加建议使用充血模型，当然贫血模型更加容易书写代码。

### MVVM

我们写界面的时候，经常会碰到一些功能，比如，从某些数据动态生成界面，然后从输入控件采集数据，经过变换，更新另外的界面。

整个这个过程，其实归纳来看，就两件事：

- 根据数据的变动，生成或者变更界面；
- 根据界面的操作，变更数据。

总结下去，就会发现，数据和界面的变更之间，一般都是存在对应关系的。既然这样，如果我们能够引入一种绑定关系，经过一系列的配置过程，使得以后每次数据发生变更，界面都会自动跟着作对应变动；界面上的操作，也会自动更新到数据，那开发过程就会非常省事了，绝大部分此类操作都会转化为配置，供绑定框架用来建立数据和界面之间的关联关系。ViewModel是Model和View之间的桥梁，为Model和View提供适配。在 MVVM 的实现中，还引入了**隐式的**一个 Binder 层，而声明式的数据和命令的绑定在 MVVM 模式中就是通过它完成的。

在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离。把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。需要用JavaScript编写一个通用的ViewModel，这样，就可以复用整个MVVM模型了。

MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新视图，从而把开发者从操作视图，同步数据的繁琐步骤中解脱出来！

**特别注意MVVM在前端非常流行，在客户端以及服务端并不常用**（通常情况下客户端Android/iOS自身提供了MVC架构，引入MVVM的成本过高；而服务端因为前后端分离的问题，View已经非常弱化，没有使用MVVM的必要，再者服务端的架构已经非常成熟，上边已有介绍）。

参考资料：

[MVVM思想](https://www.zhihu.com/question/41559085/answer/92475533)

[MVX思考](https://draveness.me/mvx/)

