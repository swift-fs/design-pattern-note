### MVC

M 表示 Model 也就是数据模型；V 表示 View 也就是界面视图；C 表示 Controller 也就是控制器，用来协调用户操作、Model、和 View。但是 **MVC 只是给出了这样一个大致的指导原则，并没有具体指明 MVC 各个部分应该承担具体什么职责，相互之间应该如何交互**。这些很大程度上都是由开发工具或者开发框架定义的，如果工具或者框架没有定义，那么就完全靠开发人员自由发挥了。

#### 客户端MVC

控制器负责对模型中的数据进行更新，而视图向模型中请求数据；当有用户的行为触发操作时，会有控制器更新模型，并通知视图进行更新，在这时视图向模型请求新的数据。所以在客户端中，一般Controller的工作量非常大（响应用户事件，更新视图，同步模型，管理视图和模型，代理应用生命周期以及页面生命周期）。执行流程大致为：V->C->M->C->V，可以看出Controller是沟通View和Model的桥梁，并且项目大部分的业务逻辑位于Controller层，而不是在Model层，Model层只起到了数据定义的作用（因此，客户端代码优化的重要方向就是把部分业务逻辑迁移到Model层）。

#### 服务端MVC

View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，**控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。**所以在服务端中，一般Model的工作量非常大（维护着数据，同时封装业务逻辑）。执行流程大致为：C->M->V，控制器的代码量非常少，接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。

### 三层架构

服务端MVC架构会有以下问题：

- 前后端分离，大多数场景下已不再需要服务端渲染`View`；
- `Model`层级的代码既维护着数据，也封装着业务逻辑，随着业务逻辑变得越来越复杂，这一层功能逻辑会变得越来越臃肿不易维护；
- 对于团队管理来讲，`Controller`和`Model`的职责边界比较模糊，很难保证参差不齐的团队成员能够清晰地认识到`Controller`层并不应当封装业务逻辑。对于开发人员写好代码的要求会比较高。

针对以上三个问题，推荐使用三层架构的模式。传统的三层架构设计分为以下三个部分：

- **UI（表示层）**：`User Interface`位于三层构架的最上层，与用户直接接触，主要是`B/S`中的 `WEB`页面，也可以是`API`接口。表示层的主要功能是实现系统数据的传入与输出。换句话说，表示层就是实现用户界面/`API`接口功能，将用户的需求传达和反馈，调用BLL完成业务逻辑，保证用户体验。
- **BLL（业务逻辑层）**：`Business Logic Layer`的功能是对具体问题进行逻辑判断与执行操作，接收到表现层`UI`的用户指令后，会连接数据访问层`DAL`，业务逻辑层在三层构架中位于表示层与数据层中间位置，同时也是表示层与数据层的桥梁，实现三层之间的数据连接和指令传达，可以对接收数据进行逻辑处理，实现数据的增删改查等功能，并将处理结果反馈到表示层`UI`中，实现软件功能。
- **DAL（数据访问层）**：`Data Access Layer`是数据库的主要操控系统，实现数据的增删改查等操作，并将操作结果反馈到业务逻辑层`BLL`。在实际运行的过程中，数据访问层没有逻辑判断能力，为了实现代码编写的严谨性，提高代码阅读程度，一般软件开发人员会在该层中实现通用数据能力，进行封装（例如通过`ORM`组件）来保证数据访问层`DAL`数据处理功能。 

但是在实际开发三种，一般会增加**Model层（模型定义层）**，它不属于三层中的任何一层，但是却尤其重要。模型定义也常用`Entity`实体对象来表示，主要用于数据库表的映射对象，在信息系统软件实际开发的过程中，要建立对象实例，将关系数据库表采用对象实体化的方式表现出来，辅助软件开发中对各个系统功能的控制与操作执行。建立实体类库，进而实现各个结构层的参数传输，提高代码的阅读性。从本质上看，实体类库主要服务于表示层、业务逻辑层以及数据访问层，在三层之间进行数据参数传输，强化数据表示的简约性。需要注意区分的是，这里的`Model`和`MVC`设计模式中的`Model`虽然都是一个名字但是差别巨大，职责完全不同。

在三层架构设计中，`UI`表示层即相当于`MVC`的`View`和`Controller`层，原本在`MVC`中这两层的逻辑应当是比较"轻量"的，因此被合并为一层进行统一管理也可以理解。比较重要的一点是，原本`MVC`中的`Model`被拆分为了`BLL`和`DAL`，即将业务逻辑与数据访问进行分离，将原本臃肿的`Model`进行了进一步的解耦，有利于项目的更好维护。

#### 贫血模型

三层架构中，每层都有对应的数据模型：

- Vo对应UI
- Bo对应BLL
- Model/Entity对应DAL

Vo，Bo，Model/Entity只包含数据，不包含任何的业务逻辑。只包含数据，不包含业务逻辑的类，就叫作贫血模型。贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。

#### 充血模型

数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。在基于贫血模型的传统开发模式中，Service/BLL 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的开发模式中，Service/BL 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的开发模式，轻 Service 重Domain。

#### 如何选择

现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式。出现这种情况的原因主要有以下几点：

- 系统业务比较简单，简单到就是基于SQL 的 CRUD 操作，贫血模型就足以应付这种简单业务的开发工作；除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。
- 充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。
- 思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。

不夸张地讲，我们平时的开发，大部分都是 SQL 驱动的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。

如果我们在项目中，应用基于充血模型的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。**领域模型相当于可复用的业务中间层**。新功能需求的开发，都基于之前定义好的这些领域模型来完成。

基于充血模型的开发模式跟基于贫血模型的传统开发模式相比，UI 层和DAL层的代码基本上相同。这是因为，UI 层和DAL层生命周期有限，UI 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，UI 层和DAL 层继续沿用贫血模型的设计思路是没有问题的。

> DAL与Domian都是Service的底层。DAL复杂数据的存储，Domian负责业务逻辑，Service将两者融合。

任何时候都更加建议使用充血模型，当然贫血模型更加容易书写代码。

### MVVM

我们写界面的时候，经常会碰到一些功能，比如，从某些数据动态生成界面，然后从输入控件采集数据，经过变换，更新另外的界面。

整个这个过程，其实归纳来看，就两件事：

- 根据数据的变动，生成或者变更界面；
- 根据界面的操作，变更数据。

总结下去，就会发现，数据和界面的变更之间，一般都是存在对应关系的。既然这样，如果我们能够引入一种绑定关系，经过一系列的配置过程，使得以后每次数据发生变更，界面都会自动跟着作对应变动；界面上的操作，也会自动更新到数据，那开发过程就会非常省事了，绝大部分此类操作都会转化为配置，供绑定框架用来建立数据和界面之间的关联关系。ViewModel是Model和View之间的桥梁，为Model和View提供适配。在 MVVM 的实现中，还引入了**隐式的**一个 Binder 层，而声明式的数据和命令的绑定在 MVVM 模式中就是通过它完成的。

在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离。把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。需要用JavaScript编写一个通用的ViewModel，这样，就可以复用整个MVVM模型了。

MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新视图，从而把开发者从操作视图，同步数据的繁琐步骤中解脱出来！

**特别注意MVVM在前端非常流行，在客户端以及服务端并不常用**（通常情况下客户端Android/iOS自身提供了MVC架构，引入MVVM的成本过高；而服务端因为前后端分离的问题，View已经非常弱化，没有使用MVVM的必要，再者服务端的架构已经非常成熟，上边已有介绍）。

参考资料：

[MVVM思想](https://www.zhihu.com/question/41559085/answer/92475533)

[MVX思考](https://draveness.me/mvx/)

### 代码为什么分层

- 分层能起到代码复用的作用。同一个 Repository 可能会被多个 Service 来调用，同一个 Service 可能会被多个Controller 调用。

- 分层能起到隔离变化的作用。分层体现了一种抽象和封装的设计思想。比如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，Service 层使用Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当我们需要替换数据库的时候，比如从 MySQL 到 Oracle，从 Oracle 到 Redis，只需要改动 Repository层的代码，Service 层的代码完全不需要修改。

- 分层能起到隔离关注点的作用。Repository 层只关注数据的读写。Service 层只关注业务逻辑，不关注数据的来源。Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好
- 分层能应对系统的复杂性。所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。

还是那句话，不管是分层、模块化，还是 OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是俗话说的“杀鸡焉用牛刀”。

### VO，BO，Entity的意义

针对 Controller、Service、Repository 三层，每层都会定义相应的数据对象，它们分别是 VO（View Object）、BO（Business Object）、Entity，例如 UserVo、UserBo、UserEntity。在实际的开发中，VO、BO、Entity 可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，我们经常需要重复定义三个几乎一样的类，显然是一种重复劳动。

> 相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？

实际上，我更加推荐每层都定义各自的数据对象这种设计思路，主要有以下 3 个方面的原因。VO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！

> 既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？

从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们也有一些办法来解决。继承可以解决代码重复问题。我们可以将公共的字段定义在父类中，让VO、BO、Entity 都继承这个父类，各自只定义特有的字段。因为这里的继承层次很浅，也不复杂，所以使用继承并不会影响代码的可读性和可维护性。后期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂。组合也可以解决代码重复的问题，所以，这里我们还可以将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码。

> 代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？

当下一层的数据通过接口调用传递到上一层之后，我们需要将它转化成上一层对应的数据对象类型。比如，Service 层从 Repository 层获取的 Entity 之后，将其转化成 BO，再继续业务逻辑的处理。所以，整个开发的过程会涉及“Entity 到 BO”和“BO 到 VO”这两种转化。最简单的转化方式是手动复制。自己写代码在两个对象之间，一个字段一个字段的赋值。但这样的做法显然是没有技术含量的低级劳动。Java 中提供了多种数据对象转化工具，比如BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作。如果你是用其他编程语言来做开发，也可以借鉴 Java 这些工具类的设计思路，自己在项目中实现对象转化工具类。

> VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？

Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。