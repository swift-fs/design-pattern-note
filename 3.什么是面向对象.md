### 面向对象编程

**面向对象编程的英文缩写是 OOP，全称是 Object Oriented Programming。**面向对象编程中有两个非常重要、非常基础的概念，那就是类（class）和对象（object）。

**面向对象编程是一种编程范式或编程风格**。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

### 面向对象编程语言

如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP、Perl 等等。**面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。**

广泛认为，某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。

### 面向对象分析和设计

跟面向对象编程经常放到一块儿来讲的还有另外两个概念，那就是面向对象分析（OOA）和面向对象设计（OOD）。面向对象分析英文缩写是 OOA，全称是 Object Oriented Analysis；面向对象设计的英文缩写是OOD，全称是 Object Oriented Design。OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。

**面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。**两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。

#### OOA如何做

针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，一定不要只关心设计与实现，前期的需求分析同等重要。

需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

#### OOD如何做

面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。在面向对象设计环节，将需求描述转化为具体的类的设计，主要包含以下几个部分：

- 划分职责进而识别出有哪些类；

> 把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。不过，我个人更喜欢另外一种方法，那就是根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。
>
> 针对复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。

- 定义类及其属性和方法；

> 我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

- 定义类与类之间的交互关系；

> UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

- 将类组装起来并提供执行入口。

> 我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。

### 封装

**封装也叫作信息隐藏或者数据访问保护**。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。对于封装这个特性，需要编程语言本身提供一定的语法机制来支持。这个语法机制就是**访问权限控制**。

封装特性存在的意义，一方面是保护数据不被随意修改，**提高代码的可维护性**；另一方面是仅暴露有限的必要接口，**提高类的易用性**。

### 抽象

**抽象讲的是如何隐藏方法的具体实现**，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。在面向对象编程中，我们常借助编程语言提供的接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。

抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

### 继承

**继承是用来表示类之间的is-a 关系**，分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。

继承主要是用来解决代码复用的问题。

### 多态

**多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。**多态这种特性也需要编程语言提供特殊的语法机制来实现。

多态可以提高代码的扩展性和复用性。

#### 继承和方法重写实现多态

第一个语法机制是编程语言要支持父类对象可以引用子类对象；第二个语法机制是编程语言要支持继承；第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法。

#### 接口实现多态

只要类实现了对应接口，就可以通过接口类型来接受该类的实例对象。

#### duck-type

只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。

### 多继承问题

多继承会带来钻石问题（菱形继承），假如C类同时继承A类和B类，A类和B类同时继承了O类，会产生以下问题：

- A类和B类拥有共同的方法，那么C类继承过来时，本身没有重写该方法，那么调用A类还是B类的？
- A类和B类由继承了O类，那么创建C类对象时，O类的构造函数会执行两次，有必要吗？

### 面向过程编程

面向过程编程也是一种编程范式或编程风格。它以过程（可以为理解方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

### 面向过程编程语言

面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

### 面向对象和面向过程

面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。

为什么面向对象更加流行？

- OOP 更加能够应对大规模复杂程序的开发
- OOP 风格的代码更易复用、易扩展、易维护
- OOP 语言更加人性化、更加高级、更加智能

### Linux源码用C写的，如何看待？

虽然操作系统是用C语言写的，但是面向对象的思想早已深入到操作系统的源代码中。面向对象思想，不局限于具体语言。利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。而且，面向过程编程和面向对象编程并非完全对立的。很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。

### 哪些代码设计看似是面向对象，实际是面向过程的？

在用面向对象编程语言进行软件开发的时候，我们有时候会写出面向过程风格的代码。有些是有意为之，并无不妥；而有些是无意为之，会影响到代码的质量。

#### 滥用getter，setter方法

面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。

在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。

#### Constants类，Utils类的设计

对于这两种类的设计，尽量能做到职责单一，定义一些细化的小类，比如RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。

#### 滥用全局变量和全局方法

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。静态方法一般用来操作静态变量或者外部数据。

#### 定义数据和方法分离的类

**数据定义在一个类中，方法定义在另一个类中。**

